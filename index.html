<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端音频处理工具 - 基于FFmpeg.wasm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        body {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .container {
            margin-top: 2rem;
        }
        .form-group {
            margin: 1.5rem 0;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        select, input, button, textarea {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 1rem;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .module {
            margin-top: 1.5rem;
            padding: 1.5rem;
            border: 1px solid #eee;
            border-radius: 6px;
        }
        .audio-item {
            margin: 1rem 0;
            padding: 1rem;
            border: 1px dashed #ccc;
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .audio-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.1);
        }
        
        .audio-item.dragging {
            opacity: 0.5;
        }
        
        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            font-weight: bold;
        }
        
        .file-type-indicator {
            margin-right: 0.5rem;
            color: #666;
            font-size: 0.9rem;
        }
        
        .file-name {
            flex-grow: 1;
            margin-right: 0.5rem;
            word-break: break-all;
        }
        
        .delete-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 0.3rem 0.6rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            width: auto;
        }
        
        .delete-btn:hover {
            background-color: #c82333;
        }
        
        .item-controls {
            padding-left: 1rem;
        }
        
        .trim-controls {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
        }
        
        .trim-progress-container {
            position: relative;
            height: 40px;
            margin-bottom: 1rem;
            background-color: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .trim-slider {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            opacity: 0;
            cursor: pointer;
        }
        
        .trim-slider.start-slider {
            z-index: 2;
        }
        
        .trim-slider.end-slider {
            z-index: 1;
        }
        
        .trim-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #007bff;
            opacity: 0.5;
            z-index: 0;
        }
        
        .trim-time-inputs {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .trim-time-inputs label {
            margin: 0;
            font-size: 0.9rem;
        }
        
        .trim-time-inputs input {
            width: 80px;
            margin: 0;
        }
        
        .play-btn, .pause-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-right: 0.5rem;
            width: auto;
        }
        
        .pause-btn {
            background-color: #ffc107;
            color: #212529;
        }
        
        .play-btn:hover {
            background-color: #218838;
        }
        
        .pause-btn:hover {
            background-color: #e0a800;
        }
        .progress {
            margin: 1rem 0;
            height: 20px;
            border-radius: 10px;
            background-color: #eee;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            width: 0;
            background-color: #28a745;
            transition: width 0.3s;
        }
        .hidden {
            display: none;
        }
        .command-group {
            margin: 2rem 0;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        h1 {
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>前端音频处理工具</h1>
    <div class="form-group">
        <label for="function-select">选择功能</label>
        <select id="function-select">
            <option value="">--请选择功能--</option>
            <option value="convert">[音频/视频]转换格式(音频提取、音频视频格式转换)</option>
            <option value="merge-volume">[音频/视频]截取、拼接与调整音量</option>
        </select>
    </div>

    <!-- FFmpeg命令预览与编辑 -->
    <div class="command-group hidden" id="command-group">
        <label for="ffmpeg-command">FFmpeg 命令（可手动修改）</label>
        <textarea id="ffmpeg-command" readonly placeholder="FFmpeg命令将在此处生成..."></textarea>
        <button id="confirm-command" type="button">确认命令并执行</button>
    </div>

    <!-- 转换格式模块 -->
    <div id="convert-module" class="module hidden">
        <h2>[音频/视频]转换格式</h2>
        <div class="form-group">
            <label for="convert-file">选择文件</label>
            <input type="file" id="convert-file" accept="audio/*,video/*">
        </div>
        <div class="form-group">
            <label for="convert-format">目标格式</label>
            <select id="convert-format">
                <!-- 选项将根据选择的文件类型动态生成 -->
            </select>
        </div>
        <div class="progress">
            <div id="convert-progress" class="progress-bar"></div>
        </div>
        <button id="generate-convert-command" type="button">生成FFmpeg命令</button>
    </div>

    <!-- 截取、拼接与调整音量模块 -->
    <div id="merge-volume-module" class="module hidden">
        <h2>[音频/视频]截取、拼接与调整音量</h2>
        <div class="form-group">
            <label for="merge-files">选择文件</label>
            <input type="file" id="merge-files" accept="audio/*,video/*" multiple>
        </div>
        <div id="audio-items-container"></div>
        <div class="progress">
            <div id="merge-volume-progress" class="progress-bar"></div>
        </div>
        <button id="generate-merge-volume-command" type="button">生成FFmpeg命令</button>
    </div>

    <script type="module">
        // 使用本地FFmpeg依赖
        import { FFmpeg } from './static/ffmpeg/ffmpeg/index.js';
        
        const ffmpeg = new FFmpeg({ 
            log: true
        });
        
        // 用于存储FFmpeg日志
        let ffmpegLogs = [];
        
        // 添加日志监听器
        ffmpeg.on('log', (log) => {
            ffmpegLogs.push(log);
            console.log('FFmpeg日志:', log);
        });
        
        let ffmpegLoaded = false;
        let loadFFmpegPromise = null;
        // 存储当前功能的上下文数据
        let currentContext = {
            type: '',
            data: null,
            outputExt: ''
        };

        // DOM元素
        const functionSelect = document.getElementById('function-select');
        const commandGroup = document.getElementById('command-group');
        const ffmpegCommandInput = document.getElementById('ffmpeg-command');
        const confirmCommandBtn = document.getElementById('confirm-command');
        const convertModule = document.getElementById('convert-module');
        const mergeVolumeModule = document.getElementById('merge-volume-module');
        const audioItemsContainer = document.getElementById('audio-items-container');

        // 功能切换
        functionSelect.addEventListener('change', (e) => {
            const value = e.target.value;
            convertModule.classList.add('hidden');
            mergeVolumeModule.classList.add('hidden');
            commandGroup.classList.add('hidden');
            audioItemsContainer.innerHTML = '';
            ffmpegCommandInput.value = '';
            currentContext = { type: '', data: null, outputExt: '' };
            
            if (value === 'convert') convertModule.classList.remove('hidden');
            else if (value === 'merge-volume') mergeVolumeModule.classList.remove('hidden');
            
            // 预加载FFmpeg
            if (!ffmpegLoaded) loadFFmpeg();
        });

        // 加载FFmpeg核心
        async function loadFFmpeg() {
            // 如果已经加载完成，直接返回
            if (ffmpegLoaded) {
                return;
            }
            
            // 如果已经有加载Promise在运行，返回该Promise
            if (loadFFmpegPromise) {
                return await loadFFmpegPromise;
            }
            
            // 创建新的加载Promise
            loadFFmpegPromise = (async () => {
                // 使用绝对URL，确保在模块类型worker中能正确加载
                const coreURL = `${window.location.origin}/static/ffmpeg/ffmpeg-core.js`;
                const wasmURL = `${window.location.origin}/static/ffmpeg/ffmpeg-core.wasm`;
                
                await ffmpeg.load({
                    coreURL: coreURL,
                    wasmURL: wasmURL,
                });
                ffmpegLoaded = true;
            })();
            
            // 等待加载完成
            await loadFFmpegPromise;
        }

        // 生成当前日期时间文件名
        function getOutputFileName(ext) {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}_${hour}${minute}${second}.${ext}`;
        }

        // ---------------------- 转换格式功能 ----------------------
        document.getElementById('convert-file').addEventListener('change', handleConvertFileSelect);
        document.getElementById('generate-convert-command').addEventListener('click', generateConvertCommand);

        // 支持的音频和视频格式
        const audioFormats = ['mp3', 'wav', 'flac', 'ogg', 'aac'];
        const videoFormats = ['mp4', 'avi', 'mov', 'webm'];

        // 根据输出格式获取合适的音频编码器
        function getAudioCodecForFormat(format) {
            switch(format) {
                case 'mp3':
                    return 'libmp3lame';
                case 'aac':
                    return 'aac';
                case 'flac':
                    return 'flac';
                case 'ogg':
                    return 'libvorbis';
                case 'wav':
                    return 'pcm_s16le';
                case 'mp4':
                case 'mov':
                case 'avi':
                case 'webm':
                    return 'aac'; // 视频格式默认使用aac音频编码
                default:
                    return 'copy';
            }
        }

        function handleConvertFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            const convertFormatSelect = document.getElementById('convert-format');
            convertFormatSelect.innerHTML = '';

            // 检测文件类型
            const isVideo = file.type.startsWith('video/');
            const isAudio = file.type.startsWith('audio/');

            // 添加所有支持的格式选项
            if (isVideo || isAudio) {
                // 添加音频格式
                audioFormats.forEach(format => {
                    const option = document.createElement('option');
                    option.value = format;
                    option.textContent = format.toUpperCase();
                    convertFormatSelect.appendChild(option);
                });
            }

            if (isVideo || isAudio) {
                // 添加视频格式
                videoFormats.forEach(format => {
                    const option = document.createElement('option');
                    option.value = format;
                    option.textContent = format.toUpperCase();
                    convertFormatSelect.appendChild(option);
                });
            }

            validateConvertForm();
        }

        function validateConvertForm() {
            const file = document.getElementById('convert-file').files[0];
            const button = document.getElementById('generate-convert-command');
            button.disabled = !file;
        }

        async function generateConvertCommand() {
            const file = document.getElementById('convert-file').files[0];
            const format = document.getElementById('convert-format').value;
            const outputFileName = getOutputFileName(format);
            
            // 确保FFmpeg已经加载完成
            if (!ffmpegLoaded) {
                await loadFFmpeg();
            }
            
            // 写入文件
            const originalExt = file.name.split('.').pop();
            const inputName = `input.${originalExt}`;
            await ffmpeg.writeFile(inputName, new Uint8Array(await file.arrayBuffer()));
            
            // 检测文件类型和输出格式类型
            const isVideoInput = file.type.startsWith('video/');
            const isAudioInput = file.type.startsWith('audio/');
            const isAudioOutput = audioFormats.includes(format);
            const isVideoOutput = videoFormats.includes(format);
            
            // 生成FFmpeg命令
            const command = ['-i', inputName];
            
            if (isVideoInput && isAudioOutput) {
                // 视频转音频 - 提取音频
                command.push('-vn'); // 不包含视频
                if (audioFormats.includes(format)) {
                    // 如果输出是音频格式，使用适当的编码器
                    command.push('-c:a', getAudioCodecForFormat(format));
                } else {
                    command.push('-acodec', 'copy');
                }
            } else if (isAudioInput && isVideoOutput) {
                // 音频转视频 - 生成无画面视频
                command.push('-f', 'lavfi', '-i', 'color=c=black:s=16x16:r=1');
                command.push('-c:v', 'libx264');
                command.push('-c:a', getAudioCodecForFormat(format));
                command.push('-shortest');
            } else if (isAudioInput && isAudioOutput) {
                // 音频转音频 - 不同格式需要重新编码
                command.push('-c:a', getAudioCodecForFormat(format));
            } else if (isVideoInput && isVideoOutput) {
                // 视频转视频
                command.push('-c:v', 'libx264');
                command.push('-c:a', getAudioCodecForFormat(format));
            } else {
                // 其他情况 - 尝试直接复制
                command.push('-c', 'copy');
            }
            
            command.push(outputFileName);
            
            // 显示命令并存储上下文（添加ffmpeg前缀）
            ffmpegCommandInput.value = `ffmpeg ${command.join(' ')}`;
            ffmpegCommandInput.readOnly = false;
            commandGroup.classList.remove('hidden');
            currentContext = {
                type: 'convert',
                data: { progressBar: document.getElementById('convert-progress') },
                outputExt: format
            };
        }

        // ---------------------- 截取、拼接与调整音量功能 ----------------------
        document.getElementById('merge-files').addEventListener('change', handleMergeFilesSelect);
        document.getElementById('generate-merge-volume-command').addEventListener('click', generateMergeVolumeCommand);

        // 存储当前选择的文件列表
        let selectedFiles = [];

        function handleMergeFilesSelect(e) {
            selectedFiles = Array.from(e.target.files);
            renderFileItems();
        }

        function renderFileItems() {
            audioItemsContainer.innerHTML = '';
            audioItemsContainer.className = 'audio-items-container';
            audioItemsContainer.setAttribute('data-sortable', 'true');
            
            selectedFiles.forEach((file, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'audio-item';
                itemDiv.draggable = true;
                itemDiv.dataset.index = index;
                
                // 检测文件类型
                const isVideo = file.type.startsWith('video/');
                const isAudio = file.type.startsWith('audio/');
                
                itemDiv.innerHTML = `
                    <div class="item-header">
                        <span class="file-type-indicator">${isVideo ? '[视频]' : '[音频]'}</span>
                        <span class="file-name">${file.name}</span>
                        <button class="delete-btn" onclick="removeFile(${index})">删除</button>
                    </div>
                    <div class="item-controls">
                        <div class="form-group">
                            <label for="volume-${index}">音量调整（分贝，不输入则不调整，如 2 或 -3）</label>
                            <input type="number" id="volume-${index}" step="0.1" placeholder="不调整请留空">
                        </div>
                        <div class="form-group">
                            <label>截取设置</label>
                            <div class="trim-controls">
                                <div class="trim-progress-container">
                                    <input type="range" id="trim-start-${index}" class="trim-slider start-slider" min="0" max="100" value="0" step="1">
                                    <input type="range" id="trim-end-${index}" class="trim-slider end-slider" min="0" max="100" value="100" step="1">
                                    <div class="trim-progress-bar"></div>
                                </div>
                                <div class="trim-time-inputs">
                                    <label>开始时间：</label>
                                    <input type="number" id="start-time-${index}" step="0.1" min="0" placeholder="0">
                                    <label>结束时间：</label>
                                    <input type="number" id="end-time-${index}" step="0.1" min="0" placeholder="全长">
                                </div>
                                <button class="play-btn" onclick="playFile(${index})">播放</button>
                                <button class="pause-btn" onclick="pauseFile(${index})")>暂停</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加拖拽事件监听
                itemDiv.addEventListener('dragstart', handleDragStart);
                itemDiv.addEventListener('dragover', handleDragOver);
                itemDiv.addEventListener('drop', handleDrop);
                
                audioItemsContainer.appendChild(itemDiv);
            });
        }

        // 删除文件
        window.removeFile = function(index) {
            selectedFiles.splice(index, 1);
            renderFileItems();
        };

        // 拖拽排序功能
        let draggedItem = null;

        function handleDragStart(e) {
            draggedItem = this;
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (draggedItem !== this) {
                const draggedIndex = parseInt(draggedItem.dataset.index);
                const targetIndex = parseInt(this.dataset.index);
                
                // 重新排列文件
                const [movedFile] = selectedFiles.splice(draggedIndex, 1);
                selectedFiles.splice(targetIndex, 0, movedFile);
                
                // 重新渲染
                renderFileItems();
            }
            
            return false;
        }

        // 播放和暂停功能（占位，实际播放需要更复杂的实现）
        window.playFile = function(index) {
            const file = selectedFiles[index];
            console.log('播放文件:', file.name);
            // 实际播放逻辑需要使用HTML5 Audio/Video API
        };

        window.pauseFile = function(index) {
            const file = selectedFiles[index];
            console.log('暂停文件:', file.name);
        };

        async function generateMergeVolumeCommand() {
            if (selectedFiles.length === 0) return;

            // 确保FFmpeg已经加载完成
            if (!ffmpegLoaded) {
                await loadFFmpeg();
            }

            const inputFiles = [];
            let outputExt = 'mp3';
            
            // 检测输出格式（使用第一个文件的格式）
            if (selectedFiles.length > 0) {
                const firstFile = selectedFiles[0];
                const isVideo = firstFile.type.startsWith('video/');
                const isAudio = firstFile.type.startsWith('audio/');
                outputExt = isVideo ? 'mp4' : 'mp3';
            }
            
            const outputFileName = getOutputFileName(outputExt);

            // 生成文件列表但不写入文件，文件将在执行命令时写入
            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                // 使用原始文件名作为输入，让命令更直观
                const originalName = file.name;
                inputFiles.push(originalName);
            }

            // 生成FFmpeg命令
            let command = [];
            for (let i = 0; i < inputFiles.length; i++) {
                command.push('-i', inputFiles[i]);
            }
            
            // 处理每个文件的截取和音量调整
            let filterComplexParts = [];
            let processedAudioStreams = [];
            let processedVideoStreams = [];
            
            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                const volume = document.getElementById(`volume-${i}`).value;
                const startTime = document.getElementById(`start-time-${i}`).value;
                const endTime = document.getElementById(`end-time-${i}`).value;
                
                // 处理音频流
                const audioStreamLabel = `[${i}:a]`;
                const processedAudioLabel = `[a${i}]`;
                
                if (volume) {
                    filterComplexParts.push(`${audioStreamLabel}volume=${volume}${processedAudioLabel}`);
                    processedAudioStreams.push(processedAudioLabel);
                } else {
                    processedAudioStreams.push(audioStreamLabel);
                }
                
                // 处理视频流
                if (file.type.startsWith('video/')) {
                    const videoStreamLabel = `[${i}:v]`;
                    processedVideoStreams.push(videoStreamLabel);
                }
            }
            
            // 添加拼接命令
            if (selectedFiles.length > 1) {
                const hasVideo = selectedFiles.some(file => file.type.startsWith('video/'));
                const hasAudio = selectedFiles.some(file => file.type.startsWith('audio/'));
                
                // 拼接参数
                let concatParams = `concat=n=${selectedFiles.length}`;
                concatParams += hasVideo ? ':v=1' : ':v=0';
                concatParams += hasAudio ? ':a=1' : ':a=0';
                
                // 输入流
                const inputStreams = [...processedVideoStreams, ...processedAudioStreams];
                
                // 输出标签
                let outputLabels = '';
                if (hasVideo) outputLabels += '[outv]';
                if (hasAudio) outputLabels += '[outa]';
                
                filterComplexParts.push(`${inputStreams.join('')}${concatParams}${outputLabels}`);
            }
            
            // 生成完整的filter_complex参数
            if (filterComplexParts.length > 0) {
                command.push('-filter_complex', filterComplexParts.join(';'));
                
                // 根据实际情况添加map参数
                const hasVideo = selectedFiles.some(file => file.type.startsWith('video/'));
                const hasAudio = selectedFiles.some(file => file.type.startsWith('audio/'));
                
                if (hasVideo) command.push('-map', '[outv]');
                if (hasAudio) command.push('-map', '[outa]');
            }
            
            // 添加必要的编码器参数
            const hasVideo = selectedFiles.some(file => file.type.startsWith('video/'));
            const hasAudio = selectedFiles.some(file => file.type.startsWith('audio/'));
            
            if (hasVideo) command.push('-c:v', 'libx264');
            if (hasAudio) {
                command.push('-c:a', 'libmp3lame');
                command.push('-q:a', '4');
            }
            
            // 添加输出文件
            command.push(outputFileName);
            
            // 显示命令并存储上下文（添加ffmpeg前缀）
            ffmpegCommandInput.value = `ffmpeg ${command.join(' ')}`;
            ffmpegCommandInput.readOnly = false;
            commandGroup.classList.remove('hidden');
            currentContext = {
                type: 'merge-volume',
                data: {
                    progressBar: document.getElementById('merge-volume-progress'),
                    files: selectedFiles // 存储files对象，以便在执行命令时使用
                },
                outputExt: outputExt
            };
        }

        // ---------------------- 确认命令并执行 ----------------------
        confirmCommandBtn.addEventListener('click', async () => {
            if (!ffmpegLoaded) {
                alert('FFmpeg 正在加载中，请稍候！');
                return;
            }

            let command = ffmpegCommandInput.value.split(' ').filter(Boolean);
            if (command.length === 0) return;

            // 移除命令中的"ffmpeg"前缀（如果有）
            if (command[0] === 'ffmpeg') {
                command = command.slice(1);
            }
            
            const outputFileName = command[command.length - 1];
            const progressBar = currentContext.data.progressBar;

            // 监听进度
            ffmpeg.on('progress', (progress) => {
                progressBar.style.width = `${progress.progress * 100}%`;
            });

            // 执行命令
            try {
                // 对于需要多个输入文件的功能，重新写入文件
                if (currentContext.type === 'merge-volume' && currentContext.data.files) {
                    const files = currentContext.data.files;
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        // 使用原始文件名作为输入，而不是固定的wav扩展名
                        const originalName = file.name;
                        await ffmpeg.writeFile(originalName, new Uint8Array(await file.arrayBuffer()));
                    }
                }
                
                console.log('执行FFmpeg命令:', command.join(' '));
                const code = await ffmpeg.exec(command);
                
                if (code !== 0) {
                    throw new Error(`FFmpeg执行失败，返回码: ${code}`);
                }
                
                // 等待一点时间确保文件写入完成
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // 检查输出文件是否存在
                let data;
                try {
                    data = await ffmpeg.readFile(outputFileName);
                    console.log('输出文件读取成功，大小:', data.length, 'bytes');
                } catch (e) {
                    console.error('无法读取输出文件，可能未生成:', e);
                    // 列出当前目录的文件，用于调试
                    try {
                        const files = await ffmpeg.listDir('/');
                        console.log('虚拟文件系统中的文件:', files);
                    } catch (listErr) {
                        console.error('无法列出文件系统内容:', listErr);
                    }
                    throw new Error(`输出文件 ${outputFileName} 未生成或读取失败`);
                }
                
                // 根据输出文件类型设置正确的MIME类型
                const ext = outputFileName.split('.').pop();
                const mimeType = ext.startsWith('mp4') || ext === 'mov' || ext === 'avi' || ext === 'webm' ? `video/${ext}` : `audio/${ext}`;
                
                const blob = new Blob([data.buffer], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = outputFileName;
                a.click();
                URL.revokeObjectURL(url);
                
                alert('处理完成！文件已下载。');
            } catch (e) {
                const errorMessage = e.message || (typeof e === 'object' ? JSON.stringify(e) : String(e));
                console.error('FFmpeg执行错误:', e);
                
                // 显示FFmpeg日志用于调试
                if (ffmpegLogs.length > 0) {
                    console.log('FFmpeg执行日志:');
                    ffmpegLogs.forEach(log => console.log(log));
                }
                
                alert(`执行失败：${errorMessage}\n详细日志请查看浏览器控制台`);
            } finally {
                progressBar.style.width = '0%';
                // 清空日志数组
                ffmpegLogs = [];
            }
        });
    </script>
</body>
</html>